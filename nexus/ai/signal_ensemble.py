"""
Signal Ensemble — Phase 4.

Aggregates signals from multiple strategies using Sharpe-weighted voting.
Sits between strategy.signal (raw signals) and ai.signal (ensemble output).

The OMS Router can be configured to read from ai.signal instead of strategy.signal,
enabling the ensemble to enhance confidence, resolve conflicts, and filter noise.

Voting mechanics:
  1. Signals are buffered within a configurable time window (default: same bar)
  2. For each (symbol, bar) group, votes are tallied with weight = strategy Sharpe ratio
  3. If weighted vote is decisive (above threshold) → emit ensemble signal
  4. Conflicting signals (BUY + SELL) → emit HOLD or lower-confidence signal
  5. Single strategy with no conflict → pass through with weight-adjusted confidence

Weight update:
  Weights are updated by SignalEnsemble.update_weights(performance_map).
  Called periodically (e.g. weekly) by the application layer with fresh backtest metrics.
  New strategies start with a default weight of 0.5 until performance data is available.

Published to: ai.signal (consumed by OMS Router when ensemble mode is enabled)
"""

from __future__ import annotations

import asyncio
import json
import logging
from collections import defaultdict, deque
from dataclasses import dataclass, field
from datetime import datetime, timedelta
from typing import Any

from nexus.bus.consumer import EventConsumer
from nexus.bus.publisher import publisher
from nexus.core.schemas import Direction, Signal

logger = logging.getLogger(__name__)

# Default weight for new strategies (before performance data is available)
_DEFAULT_WEIGHT = 0.5
# Minimum weight floor (so no strategy is completely silenced)
_MIN_WEIGHT = 0.10
# Decisive vote threshold: ensemble signal needs this fraction of total weight
_VOTE_THRESHOLD = 0.55
# Time window for grouping signals as "same bar"
_SIGNAL_WINDOW_SECONDS = 5.0


@dataclass
class EnsembleSignal:
    """Output of the ensemble — an aggregated signal with provenance metadata."""
    symbol: str
    direction: Direction
    confidence: float               # ensemble-weighted confidence
    strategy_votes: dict[str, str]  # strategy_id → direction voted
    strategy_weights: dict[str, float]
    buy_weight: float
    sell_weight: float
    timestamp: datetime
    signal_id: str = ""             # new UUID generated by ensemble

    @property
    def is_decisive(self) -> bool:
        total = self.buy_weight + self.sell_weight
        if total == 0:
            return False
        dominant = max(self.buy_weight, self.sell_weight)
        return dominant / total >= _VOTE_THRESHOLD

    def to_signal(self, strategy_id: str = "ensemble") -> Signal:
        """Convert to a standard Signal for OMS consumption."""
        return Signal(
            symbol=self.symbol,
            direction=self.direction,
            confidence=round(self.confidence, 4),
            strategy_id=strategy_id,
            metadata={
                "ensemble": True,
                "buy_weight": round(self.buy_weight, 3),
                "sell_weight": round(self.sell_weight, 3),
                "strategy_votes": self.strategy_votes,
                "decisive": self.is_decisive,
            },
        )

    def to_dict(self) -> dict[str, Any]:
        return {
            "symbol": self.symbol,
            "direction": self.direction.value,
            "confidence": round(self.confidence, 4),
            "buy_weight": round(self.buy_weight, 3),
            "sell_weight": round(self.sell_weight, 3),
            "is_decisive": self.is_decisive,
            "strategy_votes": self.strategy_votes,
            "timestamp": self.timestamp.isoformat(),
        }


class SignalEnsemble:
    """
    Reads raw strategy signals, aggregates them, and emits to ai.signal.

    Lifecycle:
        ensemble = SignalEnsemble()
        ensemble.set_weight("ma_crossover_v1", sharpe=1.2)
        ensemble.set_weight("iron_condor_v1", sharpe=0.9)
        await ensemble.start()  # begins consuming strategy.signal
        # ...
        await ensemble.stop()
    """

    def __init__(
        self,
        signal_window_seconds: float = _SIGNAL_WINDOW_SECONDS,
        vote_threshold: float = _VOTE_THRESHOLD,
        pass_through_single: bool = True,
    ) -> None:
        self._weights: dict[str, float] = {}
        self._window = signal_window_seconds
        self._threshold = vote_threshold
        self._pass_through_single = pass_through_single  # emit single-strategy signals unchanged

        # Buffer: symbol → list of (signal, received_time)
        self._buffer: dict[str, list[tuple[Signal, float]]] = defaultdict(list)
        self._consumer = EventConsumer()
        self._running = False
        self._task: asyncio.Task[None] | None = None

        # Stats
        self._processed: int = 0
        self._emitted: int = 0
        self._suppressed: int = 0

    def set_weight(self, strategy_id: str, sharpe: float) -> None:
        """
        Set the vote weight for a strategy based on its rolling Sharpe ratio.
        Weight = max(MIN_WEIGHT, sharpe) if sharpe > 0 else MIN_WEIGHT.
        """
        weight = max(_MIN_WEIGHT, sharpe) if sharpe > 0 else _MIN_WEIGHT
        self._weights[strategy_id] = round(weight, 4)
        logger.debug("SignalEnsemble: set weight %s=%.3f (Sharpe=%.2f)", strategy_id, weight, sharpe)

    def update_weights(self, performance_map: dict[str, float]) -> None:
        """
        Bulk update weights from a dict of {strategy_id: sharpe_ratio}.
        Called periodically by the application layer with fresh backtest metrics.
        """
        for sid, sharpe in performance_map.items():
            self.set_weight(sid, sharpe)
        logger.info("SignalEnsemble: weights updated for %d strategies", len(performance_map))

    # ─── Lifecycle ────────────────────────────────────────────────────────────

    async def start(self) -> None:
        await self._consumer.connect()
        await self._consumer.ensure_group("strategy.signal", "ensemble-reader")
        self._running = True
        self._task = asyncio.create_task(self._loop(), name="signal-ensemble")
        logger.info("SignalEnsemble started (window=%.1fs, threshold=%.0f%%)",
                    self._window, self._threshold * 100)

    async def stop(self) -> None:
        self._running = False
        if self._task:
            self._task.cancel()
        await self._consumer.close()

    # ─── Processing loop ──────────────────────────────────────────────────────

    async def _loop(self) -> None:
        async for msg_id, raw in self._consumer.read_group(
            "strategy.signal", "ensemble-reader", "ensemble-worker-1"
        ):
            try:
                await self._ingest(raw)
                await self._consumer.ack("strategy.signal", "ensemble-reader", msg_id)
                self._processed += 1
            except asyncio.CancelledError:
                break
            except Exception as exc:
                logger.error("SignalEnsemble processing error: %s", exc, exc_info=True)

    async def _ingest(self, raw: dict[str, str]) -> None:
        """Buffer an incoming raw signal and evaluate the window."""
        import time as _time

        payload_str = raw.get("payload", raw.get("model", "{}"))
        if isinstance(payload_str, str):
            data = json.loads(payload_str)
        else:
            data = raw

        signal = Signal.model_validate(data)
        if signal.direction == Direction.HOLD:
            return

        now = _time.monotonic()
        self._buffer[signal.symbol].append((signal, now))

        # Expire stale signals older than the window
        self._buffer[signal.symbol] = [
            (s, t) for s, t in self._buffer[signal.symbol]
            if now - t <= self._window
        ]

        # Evaluate and maybe emit
        await self._evaluate_window(signal.symbol)

    async def _evaluate_window(self, symbol: str) -> None:
        """Tally votes for all buffered signals on a symbol and emit if decisive."""
        window_signals = [s for s, _ in self._buffer[symbol]]
        if not window_signals:
            return

        # Single strategy — pass through if enabled
        unique_strats = {s.strategy_id for s in window_signals}
        if len(unique_strats) == 1 and self._pass_through_single:
            sig = window_signals[-1]
            weight = self._weights.get(sig.strategy_id, _DEFAULT_WEIGHT)
            # Scale confidence by weight (Sharpe-adjusted)
            adjusted_confidence = min(1.0, sig.confidence * (weight / max(self._weights.values(), default=1.0)) * 1.5)
            ensemble = EnsembleSignal(
                symbol=symbol,
                direction=sig.direction,
                confidence=max(sig.confidence, adjusted_confidence),
                strategy_votes={sig.strategy_id: sig.direction.value},
                strategy_weights={sig.strategy_id: weight},
                buy_weight=weight if sig.direction == Direction.BUY else 0.0,
                sell_weight=weight if sig.direction == Direction.SELL else 0.0,
                timestamp=datetime.utcnow(),
            )
            await self._emit(ensemble)
            return

        # Multi-strategy: tally weighted votes
        buy_weight = 0.0
        sell_weight = 0.0
        votes: dict[str, str] = {}
        weights_used: dict[str, float] = {}
        buy_confidence_sum = 0.0
        sell_confidence_sum = 0.0

        for sig in window_signals:
            w = self._weights.get(sig.strategy_id, _DEFAULT_WEIGHT)
            votes[sig.strategy_id] = sig.direction.value
            weights_used[sig.strategy_id] = w

            if sig.direction == Direction.BUY:
                buy_weight += w
                buy_confidence_sum += sig.confidence * w
            elif sig.direction == Direction.SELL:
                sell_weight += w
                sell_confidence_sum += sig.confidence * w

        total_weight = buy_weight + sell_weight
        if total_weight == 0:
            return

        buy_fraction = buy_weight / total_weight

        if buy_fraction >= self._threshold:
            direction = Direction.BUY
            raw_conf = buy_confidence_sum / buy_weight if buy_weight > 0 else 0.5
            dominant = buy_weight
        elif (1 - buy_fraction) >= self._threshold:
            direction = Direction.SELL
            raw_conf = sell_confidence_sum / sell_weight if sell_weight > 0 else 0.5
            dominant = sell_weight
        else:
            # Conflicting signals — suppress or emit HOLD
            self._suppressed += 1
            logger.debug(
                "SignalEnsemble: conflicting votes on %s (buy=%.2f sell=%.2f) — suppressed",
                symbol, buy_weight, sell_weight,
            )
            return

        # Confidence = raw conf × how decisive the vote was
        decisiveness = dominant / total_weight
        ensemble_confidence = round(min(1.0, raw_conf * decisiveness * 1.2), 4)

        ensemble = EnsembleSignal(
            symbol=symbol,
            direction=direction,
            confidence=ensemble_confidence,
            strategy_votes=votes,
            strategy_weights=weights_used,
            buy_weight=buy_weight,
            sell_weight=sell_weight,
            timestamp=datetime.utcnow(),
        )
        await self._emit(ensemble)

    async def _emit(self, ensemble: EnsembleSignal) -> None:
        try:
            signal = ensemble.to_signal()
            await publisher.publish("ai.signal", signal.model_dump(mode="json"))
            self._emitted += 1
            logger.debug(
                "SignalEnsemble: emitted %s %s conf=%.2f (buy_w=%.2f sell_w=%.2f)",
                ensemble.direction.value, ensemble.symbol, ensemble.confidence,
                ensemble.buy_weight, ensemble.sell_weight,
            )
        except Exception as exc:
            logger.warning("SignalEnsemble emit error: %s", exc)

    def snapshot(self) -> dict[str, Any]:
        return {
            "processed": self._processed,
            "emitted": self._emitted,
            "suppressed": self._suppressed,
            "weights": self._weights,
            "buffer_sizes": {sym: len(buf) for sym, buf in self._buffer.items()},
        }
